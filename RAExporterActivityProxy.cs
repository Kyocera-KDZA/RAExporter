// This class was generated by the Laserfiche Activity Proxy Code Generator utility.
// Version: 8.3.0.0
// Generated at: 2021/05/19 09:38:22
// Source Activity: RAExporter.RAExporterActivity, RAExporter, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// 
namespace RAExporter
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.ComponentModel;
    using System.Xml;
    using Laserfiche.ComponentModel;
    using Laserfiche.Custom.Activities;
    using Laserfiche.Custom.Activities.Design;
    using Laserfiche.Workflow.Activities;
    using Laserfiche.Workflow.ComponentModel;
    
    
    /// <summary>
    /// Provides an activity proxy for a RAExporter.RAExporterActivity.
    /// </summary>
    [ActivityTypeAttribute(typeof(RAExporterActivity))]
    [DisplayNameAttribute("R A Exporter")]
    [DescriptionAttribute("")]
    [CategoryAttribute("Custom Activities")]
    [ActivityImageAttribute(StockActivityImage.MoonBounce)]
    [DefaultPropertyAttribute(PathInputPropertyName)]
    public class RAExporterActivityProxy : CustomSingleEntryActivityProxy
    {
        
        #region Property Names
        // Note: These read-only fields provide a robust way of referencing a property's name.
        // If you rename a property, you need to update the value of the corresponding field here.
        // 
        /// <summary>The name of the PathInput property.</summary>
        protected const string PathInputPropertyName = "PathInput";
        
        /// <summary>The name of the ExtensionInput property.</summary>
        protected const string ExtensionInputPropertyName = "ExtensionInput";
        #endregion
        
        /// <summary>The backing field for the PathInput property.</summary>
        private string pathInput = "";
        
        /// <summary>The backing field for the ExtensionInput property.</summary>
        private string extensionInput = "";
        
        /// <summary>
        /// Initializes a new instance of the RAExporterActivityProxy class.
        /// </summary>
        public RAExporterActivityProxy()
        {
        }
        
        /// <summary>
        /// Gets or sets the Path property.
        /// </summary>
        [DisplayNameAttribute("Path")]
        [SortIndexAttribute(12)]
        [TextboxAttribute(true, CustomTokenType.DefaultExcludedFromMenus, CustomTokenType.None, 1, 32767, null)]
        public string PathInput
        {
            get
            {
                return this.pathInput;
            }
            set
            {
                if (this.pathInput != value)
                {
                    string old = this.pathInput;
                    this.pathInput = value;
                    this.OnPropertyChanged(PathInputPropertyName, old, value);
                }
            }
        }
        
        /// <summary>
        /// Gets or sets the Extension property.
        /// </summary>
        [DisplayNameAttribute("Extension")]
        [SortIndexAttribute(14)]
        [TextboxAttribute(true, CustomTokenType.DefaultExcludedFromMenus, CustomTokenType.None, 1, 32767, null)]
        public string ExtensionInput
        {
            get
            {
                return this.extensionInput;
            }
            set
            {
                if (this.extensionInput != value)
                {
                    string old = this.extensionInput;
                    this.extensionInput = value;
                    this.OnPropertyChanged(ExtensionInputPropertyName, old, value);
                }
            }
        }
        
        [DisplayNameAttribute("Entry")]
        [SortIndexAttribute(80)]
        [AllowBindingAttribute(true)]
        [UseDefaultEntrySelectionEditControlAttribute()]
        public override EntryInformation82 EntryInformation
        {
            get
            {
                return base.EntryInformation;
            }
            set
            {
                base.EntryInformation = value;
            }
        }
        
        #region ITokenRenamedTarget
        /// <summary>
        /// Occurs when a token is renamed (or the activity producing the token is renamed). If this activity has properties that use the renamed token, those properties need to be updated with the new token name.
        /// </summary>
        /// <param name="oldName">The token's previous name.</param>
        /// <param name="newName">The token's new name.</param>
        /// <param name="source">The activity providing the token that was renamed.</param>
        /// <param name="part">The part of the token that was renamed (activity name or token name).</param>
        /// <param name="data">Other data associated with the renamed token (e.g a RenamedToken object or a HashSet&lt;string&gt; of the activity's other tokens)</param>
        protected override void OnTokenRenamed(string oldName, string newName, object source, string part, object data)
        {
            base.OnTokenRenamed(oldName, newName, source, part, data);
            bool refreshSummary = false;

            string newValueForPathInput;
            if (this.TryUpdateNameOfTokens(this.PathInput, oldName, newName, part, data, out newValueForPathInput))
            {
                // update the property's value with the version in which the tokens have been renamed
                this.PathInput = newValueForPathInput;

                // tell the edit control (i.e. property box) to refresh (because it might display tokens that have been renamed)
                this.NotifyPropertyRefresh(PathInputPropertyName, false, true, true);

                refreshSummary = true;
            }

            string newValueForExtensionInput;
            if (this.TryUpdateNameOfTokens(this.ExtensionInput, oldName, newName, part, data, out newValueForExtensionInput))
            {
                // update the property's value with the version in which the tokens have been renamed
                this.ExtensionInput = newValueForExtensionInput;

                // tell the edit control (i.e. property box) to refresh (because it might display tokens that have been renamed)
                this.NotifyPropertyRefresh(ExtensionInputPropertyName, false, true, true);

                refreshSummary = true;
            }

            if (refreshSummary)
            {
                // tell the activity summary to refresh (because it might display tokens that have been renamed)
                this.RefreshActivitySummary();
            }
        }
        #endregion
        
        /// <summary>
        /// Gets a collection of the property names that will be validated, will support undo/redo, and will be copied when the activity is copied.
        /// </summary>
        public override ReadOnlyCollection<string> GetPropertyNames()
        {
            List<string> names = new List<string>(base.GetPropertyNames());
            names.Add(PathInputPropertyName);
            names.Add(ExtensionInputPropertyName);
            return names.AsReadOnly();
        }
        
        /// <summary>
        /// Gets the value of the specified property.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        public override object GetProperty(string propertyName)
        {
            if (propertyName == PathInputPropertyName)
            {
                return this.PathInput;
            }

            if (propertyName == ExtensionInputPropertyName)
            {
                return this.ExtensionInput;
            }

            return base.GetProperty(propertyName);
        }
        
        /// <summary>
        /// Sets the value of the specified property.
        /// </summary>
        /// <param name="propertyName">Name of the property.</param>
        /// <param name="value">The value.</param>
        public override bool SetProperty(string propertyName, object value)
        {
            if (propertyName == PathInputPropertyName)
            {
                this.PathInput = (string)value;
                return true;
            }

            if (propertyName == ExtensionInputPropertyName)
            {
                this.ExtensionInput = (string)value;
                return true;
            }

            return base.SetProperty(propertyName, value);
        }
        
        /// <summary>
        /// Informs the publisher of any code that needs to be generated for this activity.
        /// </summary>
        /// <param name="publisher">The publisher that is generating the C# code file that represents the workflow that contains this activity.</param>
        public override void Publish(IWorkflowProxyPublisher publisher)
        {
            base.Publish(publisher);

            // The publisher's AssignToProperty method generates the code that assigns the value of a property on
            // the activity proxy to the corresponding property on the runtime activity.
            // TODO: You must also add code to the Execute method that resolves the tokens in the property value.
            publisher.AssignToProperty(this, "PathInput", this.PathInput);
            // TODO: You must also add code to the Execute method that resolves the tokens in the property value.
            publisher.AssignToProperty(this, "ExtensionInput", this.ExtensionInput);
        }
        
        /// <summary>
        /// Initializes this activity's properties from XML.
        /// </summary>
        /// <param name="reader">The reader that is deserializing the activity from XML.</param>
        protected override void ReadProperties(XmlReader reader)
        {
            base.ReadProperties(reader);

            this.PathInput = PropertySerializer.Deserialize<string>(reader, PathInputPropertyName);
            this.ExtensionInput = PropertySerializer.Deserialize<string>(reader, ExtensionInputPropertyName);
        }
        
        /// <summary>
        /// Writes this activity's properties to an XML file.
        /// </summary>
        /// <param name="writer">The writer that is serializing the activity to XML.</param>
        protected override void WriteProperties(XmlWriter writer)
        {
            base.WriteProperties(writer);

            PropertySerializer.Serialize<string>(this.PathInput, writer, PathInputPropertyName);
            PropertySerializer.Serialize<string>(this.ExtensionInput, writer, ExtensionInputPropertyName);
        }
        
        /// <summary>
        /// Performs validation for the specified property by adding relevant validation errors to the ValidationErrors collection.
        /// </summary>
        /// <param name="propertyName">The name of the property to validate.</param>
        /// <param name="collection"></param>
        protected override void ValidateProperty(string propertyName, IValidationErrorCollection collection)
        {
            base.ValidateProperty(propertyName, collection);

            if (propertyName == PathInputPropertyName)
            {
                this.ValidateProperty_PathInput(collection);
            }

            if (propertyName == ExtensionInputPropertyName)
            {
                this.ValidateProperty_ExtensionInput(collection);
            }
        }
        
        /// <summary>
        /// Validates the 'PathInput' property by adding validation errors and/or warnings to the specified IValidationErrorCollection.
        /// </summary>
        protected virtual void ValidateProperty_PathInput(IValidationErrorCollection collection)
        {
            // TODO: Add code for validating the PathInput property here. For example:
            // 
            // Ensure that PathInput is not null.
            // if (string.IsNullOrEmpty(this.PathInput))
            // {
            //     collection.AddError("This property must be specified.");
            // }

            // Note: If another property is dependent on the value of this property, call
            // RefreshPropertyValidationErrors(OtherPropertyName) to ensure that the other property's validation
            // remains up-to-date.

            // Warning: Calling RefreshPropertyValidationErrors(PathInputPropertyName) within this method will
            // cause an infinite loop.
        }
        
        /// <summary>
        /// Validates the 'ExtensionInput' property by adding validation errors and/or warnings to the specified IValidationErrorCollection.
        /// </summary>
        protected virtual void ValidateProperty_ExtensionInput(IValidationErrorCollection collection)
        {
            // TODO: Add code for validating the ExtensionInput property here. For example:
            // 
            // Ensure that ExtensionInput is not null.
            // if (string.IsNullOrEmpty(this.ExtensionInput))
            // {
            //     collection.AddError("This property must be specified.");
            // }

            // Note: If another property is dependent on the value of this property, call
            // RefreshPropertyValidationErrors(OtherPropertyName) to ensure that the other property's validation
            // remains up-to-date.

            // Warning: Calling RefreshPropertyValidationErrors(ExtensionInputPropertyName) within this method
            // will cause an infinite loop.
        }
    }
}
